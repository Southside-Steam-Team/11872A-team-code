#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    flipSense,      sensorAnalog)
#pragma config(Sensor, in8,    gyroSense,      sensorAnalog)
#pragma config(Sensor, dgtl1,  noPlatLED,      sensorLEDtoVCC)
#pragma config(Sensor, dgtl2,  redALED,        sensorLEDtoVCC)
#pragma config(Sensor, dgtl3,  blueALED,       sensorLEDtoVCC)
#pragma config(Sensor, dgtl4,  farFlagLED,     sensorLEDtoVCC)
#pragma config(Sensor, dgtl5,  sonicSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl10, platJumper,     sensorDigitalIn)
#pragma config(Sensor, dgtl11, nearFarJumper,  sensorDigitalIn)
#pragma config(Sensor, dgtl12, blueRedJumper,  sensorDigitalIn)
#pragma config(Sensor, I2C_1,  rightIME,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  leftIME,        sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           right1,        tmotorVex393_MC29, PIDControl, reversed, driveRight, encoderPort, I2C_1)
#pragma config(Motor,  port3,           right2,        tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port4,           right0,        tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port5,           flipR,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           flipL,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           left0,         tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port8,           left2,         tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port9,           left1,         tmotorVex393_MC29, PIDControl, driveLeft, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

// Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

#include "./motionPlanner/motionPlanner.c"
#include "./libPID/NERD_PID.c"

int ultrasonicArray[5];
int currentValue;

// Swap two variables
int temp;
#define swap(w, z) temp = w; w = z; z = temp;
#define sort(x, y) if(x > y) { swap(x, y); }

// Median calculation
int ultrasonicMedian(int a, int b, int c, int d, int e){
    sort(a,b);
    sort(d,e);
    sort(a,c);
    sort(b,c);
    sort(a,d);
    sort(c,d);
    sort(b,e);
    sort(b,c);
    // this last one is unnecessary for the median
    // sort(d,e);

    return c;
}

// keep track of last 5 values;
// gets called each time through the PID loop
void rollingValues() {
    for (int i = 4; i > 0; i--) {
        ultrasonicArray[i] = ultrasonicArray[i-1];
    }
    // put the current value in the first position
    ultrasonicArray[0] = currentValue;
}

PID sonicPID;

//PID Driving function
void ultraSonicDriving(int rightPower, int targetClicks,
int targetDistance) {

    resetMotorEncoder(right1);
    resetMotorEncoder(left1);

    pidInit(sonicPID, 0.1, 0.5, 0.01);

    // drive straight until encoder clicks reach target
    while(getMotorEncoder(right1) < targetClicks) {

        currentValue = SensorValue[sonicSensor];

        // if this sensor value is different from the last value
        // by more than 5, replace with median
        if ((currentValue > ultrasonicArray[0] + 5) ||
            (currentValue < ultrasonicArray[0] - 5)) {
            currentValue = ultrasonicMedian(
            ultrasonicArray[0],
            ultrasonicArray[1],
            ultrasonicArray[2],
            ultrasonicArray[3],
            ultrasonicArray[4]
            );
        }

        // Get variables for datalog
        float error = targetDistance - currentValue;
        float integral = sonicPID.sigma;
        float derivative = 0;

        long dTime = (nPgmTime - sonicPID.lastTime) * 0.001;

        if (dTime != 0)
            derivative = (currentValue - sonicPID.lastValue) / dTime;

        // put them all together, as usual
        float leftPower = rightPower + pidCalculate(sonicPID, targetDistance, currentValue);

        // Log on dataLog
        datalogDataGroupStart();
        datalogAddValue(0, error);
		datalogAddValue(1, integral);
		datalogAddValue(2, derivative);
		datalogAddValue(4, leftPower);
		datalogAddValue(5, rightPower);
        datalogDataGroupEnd();

        // our chassis drive function
        profileSetMotorOutput(right1, rightPower);
        profileSetMotorOutput(left1, leftPower);

        //don't hog CPU
        wait1Msec(50);

        // update array of sensor values
        rollingValues();
    }

    // stop once targetClicks achieved
    profileSetMotorOutput(right1, 0);
    profileSetMotorOutput(left1, 0);
}
void pre_auton()
{
    // Set bStopTasksBetweenModes to false if you want to keep user created tasks
    // running between Autonomous and Driver controlled modes. You will need to
    // manage all user created tasks if set to false.
    bStopTasksBetweenModes = false;

    // Initialize motion controller
    startTask(motionPlanner);

    // Set up the motors
    createMotionProfile(right1);
    createMotionProfile(left1);

    createMotionProfile(flipR);

    // Set sensors
    profileSetSensor(right1, rightIME);
    profileSetSensor(left1, leftIME);

    profileSetSensor(flipR, flipSense);

    // Set max velocity
    profileSetMaxVelocity (right1, 1254); // 120rpm * 627 ticks per rev / 60 seconds = 1254 ticks per second
    profileSetMaxVelocity (left1, 1254);

    profileSetMaxVelocity (flipR, 10000); // 120rpm * 5564 ticks per rev (calculated) / 60 sec

    // Set slaves
    profileSetMaster(right0, right1, false);
    profileSetMaster(right2, right1, false);
    profileSetMaster(left0, left1, false);
    profileSetMaster(left2, left1, false);

    profileSetMaster(flipL, flipR, false);

    // Set accel time for flipper, as well as position controller
    profileSetAccelerationTime(flipR, 0);
    profileSetPositionController(flipR, 0.5, 1, 0.02);

    // Initialize the gyro

    // Initialize flipPID

    // Choose auton program
    // Choose blue or red alliance
}
task autonomous()
{
    // Set accel times for auton
    profileSetAccelerationTime (right1, 1000);
    profileSetAccelerationTime (left1, 1000);
}
task usercontrol()
{
    ultraSonicDriving(60, 2000, 5);
}
