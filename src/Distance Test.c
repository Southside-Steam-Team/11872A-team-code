#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    flipSense,      sensorAnalog)
#pragma config(Sensor, in8,    gyroSense,      sensorAnalog)
#pragma config(Sensor, dgtl1,  noPlatLED,      sensorLEDtoVCC)
#pragma config(Sensor, dgtl2,  redALED,        sensorLEDtoVCC)
#pragma config(Sensor, dgtl3,  blueALED,       sensorLEDtoVCC)
#pragma config(Sensor, dgtl4,  farFlagLED,     sensorLEDtoVCC)
#pragma config(Sensor, dgtl10, platJumper,     sensorDigitalIn)
#pragma config(Sensor, dgtl11, nearFarJumper,  sensorDigitalIn)
#pragma config(Sensor, dgtl12, blueRedJumper,  sensorDigitalIn)
#pragma config(Sensor, I2C_1,  rightIME,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  leftIME,        sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           right1,        tmotorVex393_MC29, PIDControl, reversed, driveRight, encoderPort, I2C_1)
#pragma config(Motor,  port3,           right2,        tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port4,           right0,        tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port5,           flipR,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           flipL,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           left0,         tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port8,           left2,         tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port9,           left1,         tmotorVex393_MC29, PIDControl, driveLeft, encoderPort, I2C_2)
#pragma config(MotorPidSetting,  port2,  50, 40, 1000, 12, 10,   33, 45, 60)
#pragma config(MotorPidSetting,  port9,  50, 40, 1000, 12, 10,   33, 45, 60)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

// Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

//#include "./motionPlanner/motionPlanner.c"
#include "./libPID/NERD_PID.c"

PID motorPositionPID;
float kP = 0.1;
float kD = 0.01;

void pre_auton()
{
    // Set bStopTasksBetweenModes to false if you want to keep user created tasks
    // running between Autonomous and Driver controlled modes. You will need to
    // manage all user created tasks if set to false.
    bStopTasksBetweenModes = true;

    resetMotorEncoder(right1);
    resetMotorEncoder(left1);

    // Initialize motor slaves
    slaveMotor(right0, right1);
    slaveMotor(right2, right1);
    slaveMotor(left0, left1);
    slaveMotor(left2, left1);

    slaveMotor(flipL, flipR);

    pidInit(motorPositionPID, kP, 0, kD);
}
void
goToPosition(long targetPosition, int maxSpeed)
{
    bool bAtTarget = false;
    long liAtTargetTime = nPgmTime;

    while (!bAtTarget)
    {
        long currentPosition = getMotorEncoder(right1);

        float error = targetPosition - currentPosition;
        float integral = motorPositionPID.sigma;
        float derivative = 0;

        long dTime = (nPgmTime - motorPositionPID.lastTime) * 0.001;

        if (dTime != 0)
            derivative = (currentPosition - motorPositionPID.lastValue) / dTime;

        // Calculate the output of the PID controller and output to drive motors
        float driveOut = pidCalculate(motorPositionPID, targetPosition, currentPosition) * maxSpeed;

        // Log on dataLog
        datalogDataGroupStart();
        datalogAddValue(0, error);
		datalogAddValue(1, integral);
		datalogAddValue(2, derivative);
		datalogAddValue(4, driveOut);
        datalogDataGroupEnd();

        motor[right1] = driveOut;
        motor[left1] = driveOut;

        // Stop the turn function when the position has been within 12 ticks of the desired encoder tick for 350ms
        if(abs(targetPosition - currentPosition) > 12)
            liAtTargetTime = nPgmTime;
        if (nPgmTime - liAtTargetTime > 350)
        {
            bAtTarget = true;
            motor[right1] = 0;
            motor[left1] = 0;
        }
    }
}
void
driveStraight(long distance, bool reset)
{
    if (reset)
    {
        resetMotorEncoder(right1);
        resetMotorEncoder(left1);
    }

    goToPosition(distance, 85);
}
task autonomous()
{
    driveStraight(3000, true);
}
task usercontrol()
{
    driveStraight(3000, true);
}
