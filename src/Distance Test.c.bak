#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    flipSense,      sensorAnalog)
#pragma config(Sensor, in8,    gyroSense,      sensorAnalog)
#pragma config(Sensor, dgtl1,  noPlatLED,      sensorLEDtoVCC)
#pragma config(Sensor, dgtl2,  redALED,        sensorLEDtoVCC)
#pragma config(Sensor, dgtl3,  blueALED,       sensorLEDtoVCC)
#pragma config(Sensor, dgtl4,  farFlagLED,     sensorLEDtoVCC)
#pragma config(Sensor, dgtl10, platJumper,     sensorDigitalIn)
#pragma config(Sensor, dgtl11, nearFarJumper,  sensorDigitalIn)
#pragma config(Sensor, dgtl12, blueRedJumper,  sensorDigitalIn)
#pragma config(Sensor, I2C_1,  rightIME,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  leftIME,        sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port2,           right1,        tmotorVex393_MC29, PIDControl, reversed, driveRight, encoderPort, I2C_1)
#pragma config(Motor,  port3,           right2,        tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port4,           right0,        tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port5,           flipR,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           flipL,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           left0,         tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port8,           left2,         tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port9,           left1,         tmotorVex393_MC29, PIDControl, driveLeft, encoderPort, I2C_2)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

// Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

//#include "./motionPlanner/motionPlanner.c"
#include "./libPID/NERD_PID.c"

PID motorPositionPID;
PID keepStraightPID;

void pre_auton()
{
    // Set bStopTasksBetweenModes to false if you want to keep user created tasks
    // running between Autonomous and Driver controlled modes. You will need to
    // manage all user created tasks if set to false.
    bStopTasksBetweenModes = true;

    resetMotorEncoder(right1);
    resetMotorEncoder(left1);

    // Initialize motor slaves
    slaveMotor(right0, right1);
    slaveMotor(right2, right1);
    slaveMotor(left0, left1);
    slaveMotor(left2, left1);

    slaveMotor(flipL, flipR);

    pidInit(motorPositionPID, 0.005, 0, 0);
    pidInit(keepStraightPID, 0.01, 0, 0);
}
void
powerMotors(int leftPower, int rightPower)
{
    motor[left1] = leftPower;
    motor[right1] = rightPower;
}
void
goToPosition(long targetPosition, int maxSpeed)
{
    bool bAtTarget = false;
    long liAtTargetTime = nPgmTime;

    while (!bAtTarget)
    {
        float currentPositionR = getMotorEncoder(right1);
        float currentPositionL = getMotorEncoder(left1) + targetPosition / 70;

        /*
        float error = targetPosition - currentPositionR;
        float integral = motorPositionPID.sigma;
        float derivative = 0;

        long dTime = (nPgmTime - motorPositionPID.lastTime) * 0.001;

        if (dTime != 0)
            derivative = (currentPositionR - motorPositionPID.lastValue) / dTime;
            */

        float error = currentPositionR - currentPositionL;
        float integral = keepStraightPID.sigma;
        float derivative = 0;

        long dTime = (nPgmTime - keepStraightPID.lastTime) * 0.001;

        if (dTime != 0)
            derivative = (currentPositionL - keepStraightPID.lastValue) / dTime;

        // Calculate the output of the PID controller and output to drive motors
        float driveOutR = pidCalculate(motorPositionPID, targetPosition, currentPositionR) * maxSpeed;
        float driveOutL = driveOutR + pidCalculate(keepStraightPID, currentPositionR, currentPositionL) * 100;

        // Log on dataLog
        datalogDataGroupStart();
        datalogAddValue(0, error);
		datalogAddValue(1, integral);
		datalogAddValue(2, derivative);
		datalogAddValue(4, driveOutR);
		datalogAddValue(5, driveOutL);
        datalogDataGroupEnd();

        powerMotors(driveOutL, driveOutR);

        // Stop the turn function when the position has been within 12 ticks of the desired encoder tick for 350ms
        if(abs(targetPosition - currentPositionR) > 12 || abs(targetPosition - currentPositionL) > 12)
            liAtTargetTime = nPgmTime;
        if (nPgmTime - liAtTargetTime > 350)
        {
            bAtTarget = true;
            powerMotors(0);
        }
    }
}
void
driveStraight(long distance, bool reset)
{
    if (reset)
    {
        resetMotorEncoder(right1);
        resetMotorEncoder(left1);
    }

    goToPosition(distance, 100);
}
task autonomous()
{
    driveStraight(3000, true);
}
task usercontrol()
{
    driveStraight(3000, true);
}
